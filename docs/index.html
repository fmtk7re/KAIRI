<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Futures Monitor</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0d1117; color: #c9d1d9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace; padding: 16px; }
h1 { font-size: 1.2em; margin-bottom: 4px; }
.status { font-size: 0.85em; color: #8b949e; margin-bottom: 12px; }

/* ---- Symbol selector ---- */
.symbol-selector { position: relative; max-width: 420px; margin-bottom: 16px; }
.search-box {
  display: flex; align-items: center; gap: 8px;
  background: #161b22; border: 1px solid #30363d; border-radius: 6px;
  padding: 6px 12px; cursor: text;
}
.search-box .current { color: #58a6ff; font-weight: bold; font-size: 1em; min-width: 40px; }
.search-box input {
  flex: 1; background: none; border: none; color: #c9d1d9;
  font-size: 0.95em; outline: none; padding: 4px 0;
  font-family: inherit;
}
.search-box input::placeholder { color: #484f58; }
.search-box .count { font-size: 0.75em; color: #484f58; white-space: nowrap; }
.dropdown {
  position: absolute; top: 100%; left: 0; right: 0; max-height: 340px;
  overflow-y: auto; background: #161b22; border: 1px solid #30363d;
  border-top: none; border-radius: 0 0 6px 6px; display: none; z-index: 100;
}
.dropdown.show { display: block; }
.dropdown .item {
  padding: 8px 12px; cursor: pointer; font-size: 0.9em;
  display: flex; justify-content: space-between; align-items: center;
  border-bottom: 1px solid #21262d;
}
.dropdown .item:hover, .dropdown .item.highlight { background: #1f6feb; color: #fff; }
.dropdown .item .sym { font-weight: bold; }
.dropdown .item .meta { font-size: 0.75em; color: #8b949e; }
.dropdown .item:hover .meta, .dropdown .item.highlight .meta { color: #c9d1d9; }
.dropdown .empty { padding: 12px; text-align: center; color: #484f58; font-size: 0.85em; }

/* ---- Cards & charts ---- */
.charts { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.chart-box { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px; }
.chart-box h2 { font-size: 0.9em; margin-bottom: 8px; color: #58a6ff; }
canvas { width: 100% !important; }
.latest { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 16px; }
.card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px; }
.card h3 { font-size: 0.8em; color: #8b949e; margin-bottom: 6px; }
.card .val { font-size: 1.3em; font-weight: bold; }
.pos { color: #3fb950; }
.neg { color: #f85149; }
.live-badge { display: inline-block; background: #238636; color: #fff; font-size: 0.7em; padding: 2px 6px; border-radius: 4px; margin-left: 6px; vertical-align: middle; }
.live-badge.error { background: #da3633; }
.live-badge.warn { background: #9e6a03; }
.chart-status { font-size: 0.75em; color: #8b949e; margin-bottom: 8px; }
.chart-status.stale { color: #d29922; }

@media (max-width: 900px) {
  .charts { grid-template-columns: 1fr; }
  .latest { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<h1>Perpetual Futures Monitor <span class="live-badge" id="liveBadge">---</span></h1>
<div class="status" id="status">Loading symbols…</div>

<!-- Symbol selector -->
<div class="symbol-selector" id="selectorWrap">
  <div class="search-box" id="searchBox">
    <span class="current" id="currentSymbol">---</span>
    <input type="text" id="symbolSearch" placeholder="Search symbol…" autocomplete="off">
    <span class="count" id="symbolCount"></span>
  </div>
  <div class="dropdown" id="dropdown"></div>
</div>

<div class="latest" id="latest"></div>
<div class="chart-status" id="chartStatus"></div>
<div class="charts">
  <div class="chart-box"><h2>Last Price</h2><canvas id="chartLast"></canvas></div>
  <div class="chart-box"><h2>Price Gap (Last %)</h2><canvas id="chartGap"></canvas></div>
  <div class="chart-box"><h2>FR (8h Normalized)</h2><canvas id="chartFR"></canvas></div>
  <div class="chart-box"><h2>FR (8h) Gap</h2><canvas id="chartFRGap"></canvas></div>
</div>

<script>
// ======================================================================
// Config
// ======================================================================
const REPO = 'fmtk7re/KAIRI';
const BRANCH = 'main';
const CHART_REFRESH_SEC = 60;
const LIVE_REFRESH_SEC = 15;
const LS_KEY = 'kairi_selected_pair';

// CORS proxy fallback chain – try each in order
const CORS_PROXIES = [
  url => 'https://corsproxy.io/?' + encodeURIComponent(url),
  url => 'https://api.allorigins.win/raw?url=' + encodeURIComponent(url),
  url => 'https://api.codetabs.com/v1/proxy?quest=' + encodeURIComponent(url),
];
let activeProxyIdx = 0;

// State
let allPairs = [];
let pairMap = {};
let currentPair = '';
let phemexFiCache = {};
let hlIndex = -1;

// ======================================================================
// Charts
// ======================================================================
const CHART_COLORS = { gate: '#58a6ff', phemex: '#f0883e', gap: '#a371f7' };
const CHART_OPTS = {
  responsive: true,
  animation: false,
  scales: {
    x: { type: 'time', time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
         ticks: { color: '#8b949e', maxTicksLimit: 12 }, grid: { color: '#21262d' } },
    y: { ticks: { color: '#8b949e' }, grid: { color: '#21262d' } }
  },
  plugins: { legend: { labels: { color: '#c9d1d9' } } }
};

let charts = {};

function initCharts() {
  ['chartLast', 'chartGap', 'chartFR', 'chartFRGap'].forEach(id => {
    const ctx = document.getElementById(id).getContext('2d');
    charts[id] = new Chart(ctx, { type: 'line', data: { datasets: [] }, options: structuredClone(CHART_OPTS) });
  });
}

// ======================================================================
// CORS proxy with fallback
// ======================================================================
async function proxiedFetch(url) {
  for (let attempt = 0; attempt < CORS_PROXIES.length; attempt++) {
    const idx = (activeProxyIdx + attempt) % CORS_PROXIES.length;
    try {
      const proxyUrl = CORS_PROXIES[idx](url);
      const r = await fetch(proxyUrl);
      if (r.ok) {
        activeProxyIdx = idx;
        return r;
      }
    } catch { /* try next */ }
  }
  return new Response(null, { status: 502 });
}

// ======================================================================
// Symbol discovery: pairs.json → API → hardcoded
// ======================================================================
async function loadPairsJson() {
  const url = `https://raw.githubusercontent.com/${REPO}/${BRANCH}/data/pairs.json?t=${Date.now()}`;
  const r = await fetch(url);
  if (!r.ok) throw new Error('pairs.json not found');
  return await r.json();
}

async function discoverFromAPIs() {
  const [gateRes, phemexRes] = await Promise.all([
    proxiedFetch('https://api.gateio.ws/api/v4/futures/usdt/contracts'),
    proxiedFetch('https://api.phemex.com/public/products'),
  ]);
  if (!gateRes.ok || !phemexRes.ok) throw new Error('API fetch failed');

  const gateContracts = await gateRes.json();
  const phemexBody = await phemexRes.json();
  const phemexProducts = (phemexBody.data || phemexBody).perpProductsV2 || [];

  const gateMap = {};
  for (const c of gateContracts) {
    const name = c.name || '';
    if (name.endsWith('_USDT')) gateMap[name.slice(0, -5)] = name;
  }

  const phemexMap = {};
  for (const p of phemexProducts) {
    const sym = p.symbol || '';
    if (sym.endsWith('USDT')) {
      const base = sym.slice(0, -4);
      phemexMap[base] = sym;
      const fi = p.fundingInterval;
      if (fi && fi > 0) phemexFiCache[sym] = fi / 3600;
    }
  }

  return Object.keys(gateMap)
    .filter(b => phemexMap[b])
    .sort()
    .map(base => ({ name: base, gate: gateMap[base], phemex: phemexMap[base] }));
}

async function discoverSymbols() {
  try {
    const raw = await loadPairsJson();
    if (raw && raw.length > 0) {
      applyPairs(raw);
      console.log(`Loaded ${raw.length} pairs from pairs.json`);
      fetchPhemexFICache();
      return;
    }
  } catch (e) { console.warn('pairs.json unavailable:', e.message); }

  try {
    const raw = await discoverFromAPIs();
    if (raw && raw.length > 0) {
      applyPairs(raw);
      console.log(`Discovered ${raw.length} pairs from APIs`);
      return;
    }
  } catch (e) { console.warn('API discovery failed:', e.message); }

  applyPairs([
    { name: 'RIVER', gate: 'RIVER_USDT', phemex: 'RIVERUSDT' },
    { name: 'SENT',  gate: 'SENT_USDT',  phemex: 'SENTUSDT' },
  ]);
  console.warn('Using hardcoded fallback pairs');
}

function applyPairs(raw) {
  allPairs = raw.map(p => ({ base: p.name, gate: p.gate, phemex: p.phemex }));
  pairMap = {};
  for (const p of allPairs) pairMap[p.base] = p;
}

async function fetchPhemexFICache() {
  try {
    const r = await proxiedFetch('https://api.phemex.com/public/products');
    if (!r.ok) return;
    const body = await r.json();
    const products = (body.data || body).perpProductsV2 || [];
    for (const p of products) {
      const fi = p.fundingInterval;
      if (p.symbol && fi && fi > 0) phemexFiCache[p.symbol] = fi / 3600;
    }
  } catch { /* non-critical */ }
}

// ======================================================================
// Searchable dropdown
// ======================================================================
function renderDropdown(filter = '') {
  const dd = document.getElementById('dropdown');
  const q = filter.toUpperCase();
  const filtered = q ? allPairs.filter(p => p.base.toUpperCase().includes(q)) : allPairs;

  if (filtered.length === 0) {
    dd.innerHTML = '<div class="empty">No matching symbols</div>';
    dd.classList.add('show');
    hlIndex = -1;
    return filtered;
  }

  dd.innerHTML = filtered.map((p, i) =>
    `<div class="item${i === hlIndex ? ' highlight' : ''}" data-base="${p.base}">
       <span class="sym">${p.base}</span>
       <span class="meta">${p.gate} / ${p.phemex}</span>
     </div>`
  ).join('');
  dd.classList.add('show');

  dd.querySelectorAll('.item').forEach(el => {
    el.addEventListener('click', () => selectPair(el.dataset.base));
  });

  return filtered;
}

function selectPair(base) {
  if (!pairMap[base]) return;
  currentPair = base;
  document.getElementById('currentSymbol').textContent = base;
  document.getElementById('symbolSearch').value = '';
  document.getElementById('dropdown').classList.remove('show');
  hlIndex = -1;
  try { localStorage.setItem(LS_KEY, base); } catch {}
  refreshLive();
  refreshCharts();
}

function setupSelector() {
  const input = document.getElementById('symbolSearch');
  const dd = document.getElementById('dropdown');
  const box = document.getElementById('searchBox');

  document.getElementById('symbolCount').textContent = `${allPairs.length} pairs`;

  let filtered = allPairs;

  input.addEventListener('focus', () => {
    hlIndex = -1;
    filtered = renderDropdown(input.value);
  });

  input.addEventListener('input', () => {
    hlIndex = -1;
    filtered = renderDropdown(input.value);
  });

  input.addEventListener('keydown', (e) => {
    const items = dd.querySelectorAll('.item');
    if (e.key === 'ArrowDown') {
      e.preventDefault();
      hlIndex = Math.min(hlIndex + 1, items.length - 1);
      updateHighlight(items);
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      hlIndex = Math.max(hlIndex - 1, 0);
      updateHighlight(items);
    } else if (e.key === 'Enter') {
      e.preventDefault();
      if (hlIndex >= 0 && items[hlIndex]) {
        selectPair(items[hlIndex].dataset.base);
      } else if (filtered.length > 0) {
        selectPair(filtered[0].base);
      }
    } else if (e.key === 'Escape') {
      dd.classList.remove('show');
      input.blur();
    }
  });

  document.addEventListener('click', (e) => {
    if (!document.getElementById('selectorWrap').contains(e.target)) {
      dd.classList.remove('show');
    }
  });

  box.addEventListener('click', () => input.focus());
}

function updateHighlight(items) {
  items.forEach((el, i) => {
    el.classList.toggle('highlight', i === hlIndex);
  });
  if (items[hlIndex]) items[hlIndex].scrollIntoView({ block: 'nearest' });
}

// ======================================================================
// Helpers
// ======================================================================
function fmtPrice(v) {
  if (v >= 1000) return v.toFixed(2);
  if (v >= 1)    return v.toFixed(4);
  if (v >= 0.01) return v.toFixed(6);
  return v.toFixed(8);
}

function todayStr() {
  const d = new Date();
  return d.getUTCFullYear().toString() +
    (d.getUTCMonth()+1).toString().padStart(2,'0') +
    d.getUTCDate().toString().padStart(2,'0');
}

function yesterdayStr() {
  const d = new Date(Date.now() - 86400000);
  return d.getUTCFullYear().toString() +
    (d.getUTCMonth()+1).toString().padStart(2,'0') +
    d.getUTCDate().toString().padStart(2,'0');
}

async function fetchCSV(dateStr, pair) {
  const url = `https://raw.githubusercontent.com/${REPO}/${BRANCH}/data/${dateStr}_${pair.toLowerCase()}_futures.csv?t=${Date.now()}`;
  try {
    const r = await fetch(url);
    if (!r.ok) return [];
    const text = await r.text();
    return parseCSV(text);
  } catch { return []; }
}

function parseCSV(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 2) return [];
  const header = lines[0].split(',');
  return lines.slice(1).map(line => {
    const vals = line.split(',');
    const obj = {};
    header.forEach((h, i) => obj[h.trim()] = vals[i]?.trim() || '');
    return obj;
  });
}

// ======================================================================
// Live API calls
// ======================================================================
async function fetchLiveGate(symbol) {
  try {
    const url = `https://api.gateio.ws/api/v4/futures/usdt/contracts/${symbol}`;
    const r = await proxiedFetch(url);
    if (!r.ok) return null;
    const d = await r.json();
    const lp = parseFloat(d.last_price);
    if (!lp || lp <= 0) return null;
    const fiHours = (d.funding_interval || 0) / 3600;
    const fr = parseFloat(d.funding_rate || '0');
    const fr8h = fiHours > 0 ? fr * (8 / fiHours) : 0;
    return { last_price: lp, mark_price: parseFloat(d.mark_price || '0'),
             index_price: parseFloat(d.index_price || '0'),
             funding_rate: fr, funding_interval_hours: fiHours, funding_rate_8h: fr8h };
  } catch { return null; }
}

async function fetchLivePhemex(symbol) {
  try {
    const url = `https://api.phemex.com/md/v2/ticker/24hr?symbol=${symbol}`;
    const r = await proxiedFetch(url);
    if (!r.ok) return null;
    const body = await r.json();
    if (body.error !== undefined && body.error !== null) return null;
    const d = body.result || {};
    const lp = parseFloat(d.closeRp);
    if (!lp || lp <= 0) return null;
    const fiHours = phemexFiCache[symbol] || 4;
    const fr = parseFloat(d.fundingRateRr || '0');
    const fr8h = fiHours > 0 ? fr * (8 / fiHours) : 0;
    return { last_price: lp, mark_price: parseFloat(d.markPriceRp || '0'),
             index_price: parseFloat(d.indexPriceRp || '0'),
             funding_rate: fr, funding_interval_hours: fiHours, funding_rate_8h: fr8h };
  } catch { return null; }
}

// ======================================================================
// Render
// ======================================================================
function renderLatest(gate, phemex) {
  const gLast = gate.last_price, pLast = phemex.last_price;
  const gap = pLast ? ((gLast - pLast) / pLast * 100) : 0;
  const gFR8h = gate.funding_rate_8h * 100;
  const pFR8h = phemex.funding_rate_8h * 100;
  const frGap = gFR8h - pFR8h;

  const cls = v => v >= 0 ? 'pos' : 'neg';
  const sign = v => v >= 0 ? '+' : '';

  document.getElementById('latest').innerHTML = `
    <div class="card">
      <h3>Last Price</h3>
      <div>Gate: <span class="val">${fmtPrice(gLast)}</span></div>
      <div>Phemex: <span class="val">${fmtPrice(pLast)}</span></div>
    </div>
    <div class="card">
      <h3>Price Gap (Gate - Phemex)</h3>
      <div class="val ${cls(gap)}">${sign(gap)}${gap.toFixed(4)}%</div>
    </div>
    <div class="card">
      <h3>FR (8h Normalized)</h3>
      <div>Gate: <span class="${cls(gFR8h)}">${sign(gFR8h)}${gFR8h.toFixed(4)}%</span> (${gate.funding_interval_hours.toFixed(0)}h)</div>
      <div>Phemex: <span class="${cls(pFR8h)}">${sign(pFR8h)}${pFR8h.toFixed(4)}%</span> (${phemex.funding_interval_hours.toFixed(0)}h)</div>
      <div>Gap: <span class="val ${cls(frGap)}">${sign(frGap)}${frGap.toFixed(4)}%</span></div>
    </div>
  `;
}

function latestFromCSV(rows) {
  const gate = rows.filter(r => r.exchange === 'gate');
  const phemex = rows.filter(r => r.exchange === 'phemex');
  const g = gate[gate.length - 1];
  const p = phemex[phemex.length - 1];
  if (!g || !p) return null;
  return {
    gate: { last_price: parseFloat(g.last_price), mark_price: parseFloat(g.mark_price),
            index_price: parseFloat(g.index_price), funding_rate_8h: parseFloat(g.funding_rate_8h),
            funding_interval_hours: parseFloat(g.funding_interval_h || '0') },
    phemex: { last_price: parseFloat(p.last_price), mark_price: parseFloat(p.mark_price),
              index_price: parseFloat(p.index_price), funding_rate_8h: parseFloat(p.funding_rate_8h),
              funding_interval_hours: parseFloat(p.funding_interval_h || '0') }
  };
}

async function refreshLive() {
  if (!currentPair || !pairMap[currentPair]) return;
  const symbols = pairMap[currentPair];
  const badge = document.getElementById('liveBadge');
  const now = new Date().toLocaleTimeString();

  const [gate, phemex] = await Promise.all([
    fetchLiveGate(symbols.gate),
    fetchLivePhemex(symbols.phemex),
  ]);

  if (gate && phemex) {
    renderLatest(gate, phemex);
    badge.textContent = 'LIVE';
    badge.className = 'live-badge';
    document.getElementById('status').textContent =
      `${currentPair} | LIVE ${now} | Next: ${LIVE_REFRESH_SEC}s`;
    return;
  }

  // Fallback: CSV
  let rows = await fetchCSV(todayStr(), currentPair);
  if (rows.length === 0) rows = await fetchCSV(yesterdayStr(), currentPair);
  const csv = latestFromCSV(rows);
  if (csv) {
    renderLatest(csv.gate, csv.phemex);
    badge.textContent = 'CSV';
    badge.className = 'live-badge error';
    document.getElementById('status').textContent =
      `${currentPair} | CSV fallback ${now} | API unavailable`;
  } else {
    badge.textContent = 'OFFLINE';
    badge.className = 'live-badge error';
    document.getElementById('status').textContent =
      `${currentPair} | No data available | ${now}`;
  }
}

// ======================================================================
// Chart updates (from CSV)
// ======================================================================
function updateCharts(rows) {
  const gate = rows.filter(r => r.exchange === 'gate');
  const phemex = rows.filter(r => r.exchange === 'phemex');

  charts.chartLast.data.datasets = [
    { label: 'Gate', data: gate.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.last_price) })),
      borderColor: CHART_COLORS.gate, borderWidth: 1.5, pointRadius: 0, tension: 0.2 },
    { label: 'Phemex', data: phemex.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.last_price) })),
      borderColor: CHART_COLORS.phemex, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartLast.update();

  const gapData = [];
  const gateMap = new Map(gate.map(r => [r.timestamp, r]));
  phemex.forEach(p => {
    const g = gateMap.get(p.timestamp);
    if (g) {
      const gp = parseFloat(g.last_price), pp = parseFloat(p.last_price);
      if (pp) gapData.push({ x: new Date(p.timestamp), y: ((gp - pp) / pp * 100) });
    }
  });
  charts.chartGap.data.datasets = [
    { label: 'Gap %', data: gapData, borderColor: CHART_COLORS.gap, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartGap.update();

  charts.chartFR.data.datasets = [
    { label: 'Gate FR(8h)', data: gate.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.funding_rate_8h) * 100 })),
      borderColor: CHART_COLORS.gate, borderWidth: 1.5, pointRadius: 0, tension: 0.2 },
    { label: 'Phemex FR(8h)', data: phemex.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.funding_rate_8h) * 100 })),
      borderColor: CHART_COLORS.phemex, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartFR.options.scales.y.ticks.callback = v => v.toFixed(2) + '%';
  charts.chartFR.update();

  const frGapData = [];
  phemex.forEach(p => {
    const g = gateMap.get(p.timestamp);
    if (g) {
      frGapData.push({ x: new Date(p.timestamp), y: (parseFloat(g.funding_rate_8h) - parseFloat(p.funding_rate_8h)) * 100 });
    }
  });
  charts.chartFRGap.data.datasets = [
    { label: 'FR(8h) Gap', data: frGapData, borderColor: CHART_COLORS.gap, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartFRGap.options.scales.y.ticks.callback = v => v.toFixed(2) + '%';
  charts.chartFRGap.update();

  // Show data staleness info
  updateChartStatus(rows);
}

function updateChartStatus(rows) {
  const el = document.getElementById('chartStatus');
  if (!rows || rows.length === 0) {
    el.textContent = '';
    el.className = 'chart-status';
    return;
  }
  const timestamps = rows.map(r => new Date(r.timestamp)).filter(d => !isNaN(d));
  if (timestamps.length === 0) { el.textContent = ''; return; }
  const last = new Date(Math.max(...timestamps));
  const first = new Date(Math.min(...timestamps));
  const ageMin = Math.round((Date.now() - last.getTime()) / 60000);
  const fmt = d => d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  const points = Math.floor(rows.length / 2);

  let text = `Chart: ${fmt(first)} – ${fmt(last)} (${points} pts)`;
  if (ageMin > 15) {
    text += ` | Data is ${ageMin}min old`;
    el.className = 'chart-status stale';
  } else {
    el.className = 'chart-status';
  }
  el.textContent = text;
}

async function refreshCharts() {
  if (!currentPair) return;
  let rows = await fetchCSV(todayStr(), currentPair);
  if (rows.length === 0) rows = await fetchCSV(yesterdayStr(), currentPair);
  if (rows.length === 0) {
    Object.values(charts).forEach(c => { c.data.datasets = []; c.update(); });
    updateChartStatus([]);
    return;
  }
  updateCharts(rows);
}

// ======================================================================
// Init
// ======================================================================
let liveTimer = null;
let chartTimer = null;

async function init() {
  initCharts();
  document.getElementById('status').textContent = 'Discovering symbols…';

  await discoverSymbols();

  setupSelector();

  // Restore last selected pair from localStorage, or pick first
  let initial = allPairs.length > 0 ? allPairs[0].base : '';
  try {
    const saved = localStorage.getItem(LS_KEY);
    if (saved && pairMap[saved]) initial = saved;
  } catch {}
  if (initial) selectPair(initial);

  liveTimer = setInterval(refreshLive, LIVE_REFRESH_SEC * 1000);
  chartTimer = setInterval(refreshCharts, CHART_REFRESH_SEC * 1000);
}

init();
</script>
</body>
</html>

<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Futures Monitor</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0d1117; color: #c9d1d9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', monospace; padding: 16px; }
h1 { font-size: 1.2em; margin-bottom: 4px; }
.status { font-size: 0.85em; color: #8b949e; margin-bottom: 12px; }
.tabs { display: flex; gap: 8px; margin-bottom: 16px; }
.tab { padding: 6px 16px; border: 1px solid #30363d; border-radius: 6px; background: #161b22; color: #8b949e; cursor: pointer; font-size: 0.9em; }
.tab.active { background: #1f6feb; color: #fff; border-color: #1f6feb; }
.charts { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
.chart-box { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px; }
.chart-box h2 { font-size: 0.9em; margin-bottom: 8px; color: #58a6ff; }
canvas { width: 100% !important; }
.latest { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; margin-bottom: 16px; }
.card { background: #161b22; border: 1px solid #30363d; border-radius: 8px; padding: 12px; }
.card h3 { font-size: 0.8em; color: #8b949e; margin-bottom: 6px; }
.card .val { font-size: 1.3em; font-weight: bold; }
.pos { color: #3fb950; }
.neg { color: #f85149; }
.live-badge { display: inline-block; background: #238636; color: #fff; font-size: 0.7em; padding: 2px 6px; border-radius: 4px; margin-left: 6px; vertical-align: middle; }
.live-badge.error { background: #da3633; }
@media (max-width: 900px) {
  .charts { grid-template-columns: 1fr; }
  .latest { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<h1>Perpetual Futures Monitor <span class="live-badge" id="liveBadge">---</span></h1>
<div class="status" id="status">Connecting...</div>

<div class="tabs" id="tabs"></div>
<div class="latest" id="latest"></div>
<div class="charts">
  <div class="chart-box"><h2>Last Price</h2><canvas id="chartLast"></canvas></div>
  <div class="chart-box"><h2>Price Gap (Last %)</h2><canvas id="chartGap"></canvas></div>
  <div class="chart-box"><h2>FR (8h Normalized)</h2><canvas id="chartFR"></canvas></div>
  <div class="chart-box"><h2>FR (8h) Gap</h2><canvas id="chartFRGap"></canvas></div>
</div>

<script>
const REPO = 'fmtk7re/KAIRI';
const BRANCH = 'main';
const CHART_REFRESH_SEC = 60;
const LIVE_REFRESH_SEC = 15;
const PAIRS = ['RIVER', 'SENT'];
const PAIR_SYMBOLS = {
  RIVER: { gate: 'RIVER_USDT', phemex: 'RIVERUSDT' },
  SENT:  { gate: 'SENT_USDT',  phemex: 'SENTUSDT' },
};

let currentPair = PAIRS[0];
// Cache: phemex symbol -> funding interval hours (fetched once from /public/products)
let phemexFiCache = {};

const CHART_COLORS = { gate: '#58a6ff', phemex: '#f0883e', gap: '#a371f7' };
const CHART_OPTS = {
  responsive: true,
  animation: false,
  scales: {
    x: { type: 'time', time: { unit: 'minute', displayFormats: { minute: 'HH:mm' } },
         ticks: { color: '#8b949e', maxTicksLimit: 12 }, grid: { color: '#21262d' } },
    y: { ticks: { color: '#8b949e' }, grid: { color: '#21262d' } }
  },
  plugins: { legend: { labels: { color: '#c9d1d9' } } }
};

let charts = {};

function initCharts() {
  const ids = ['chartLast', 'chartGap', 'chartFR', 'chartFRGap'];
  ids.forEach(id => {
    const ctx = document.getElementById(id).getContext('2d');
    charts[id] = new Chart(ctx, { type: 'line', data: { datasets: [] }, options: structuredClone(CHART_OPTS) });
  });
}

function renderTabs() {
  const container = document.getElementById('tabs');
  container.innerHTML = PAIRS.map(p =>
    `<div class="tab ${p === currentPair ? 'active' : ''}" data-pair="${p}">${p}</div>`
  ).join('');
  container.querySelectorAll('.tab').forEach(el => {
    el.addEventListener('click', () => {
      currentPair = el.dataset.pair;
      renderTabs();
      refreshCharts();
      refreshLive();
    });
  });
}

function todayStr() {
  const d = new Date();
  return d.getUTCFullYear().toString() +
    (d.getUTCMonth()+1).toString().padStart(2,'0') +
    d.getUTCDate().toString().padStart(2,'0');
}

function yesterdayStr() {
  const d = new Date(Date.now() - 86400000);
  return d.getUTCFullYear().toString() +
    (d.getUTCMonth()+1).toString().padStart(2,'0') +
    d.getUTCDate().toString().padStart(2,'0');
}

async function fetchCSV(dateStr, pair) {
  const url = `https://raw.githubusercontent.com/${REPO}/${BRANCH}/data/${dateStr}_${pair.toLowerCase()}_futures.csv?t=${Date.now()}`;
  try {
    const r = await fetch(url);
    if (!r.ok) return [];
    const text = await r.text();
    return parseCSV(text);
  } catch { return []; }
}

function parseCSV(text) {
  const lines = text.trim().split('\n');
  if (lines.length < 2) return [];
  const header = lines[0].split(',');
  return lines.slice(1).map(line => {
    const vals = line.split(',');
    const obj = {};
    header.forEach((h, i) => obj[h.trim()] = vals[i]?.trim() || '');
    return obj;
  });
}

// --- Live API calls (via CORS proxy) ---

const CORS_PROXY = 'https://corsproxy.io/?url=';

async function proxiedFetch(url) {
  return fetch(CORS_PROXY + encodeURIComponent(url));
}

async function fetchPhemexFundingIntervals() {
  try {
    const r = await proxiedFetch('https://api.phemex.com/public/products');
    if (!r.ok) return;
    const body = await r.json();
    const products = (body.data || body).perpProductsV2 || [];
    for (const p of products) {
      const fi = p.fundingInterval;
      if (p.symbol && fi && fi > 0) {
        phemexFiCache[p.symbol] = fi / 3600;
      }
    }
  } catch (e) { console.warn('Failed to fetch Phemex products:', e); }
}

async function fetchLiveGate(symbol) {
  try {
    const url = `https://api.gateio.ws/api/v4/futures/usdt/contracts/${symbol}`;
    const r = await proxiedFetch(url);
    if (!r.ok) { console.warn('Gate API status:', r.status); return null; }
    const d = await r.json();
    const lp = parseFloat(d.last_price);
    if (!lp || lp <= 0) { console.warn('Gate bad last_price:', d.last_price); return null; }
    const fiHours = (d.funding_interval || 0) / 3600;
    const fr = parseFloat(d.funding_rate || '0');
    const fr8h = fiHours > 0 ? fr * (8 / fiHours) : 0;
    return {
      last_price: lp,
      mark_price: parseFloat(d.mark_price || '0'),
      index_price: parseFloat(d.index_price || '0'),
      funding_rate: fr,
      funding_interval_hours: fiHours,
      funding_rate_8h: fr8h,
    };
  } catch (e) { console.warn('Gate fetch error:', e); return null; }
}

async function fetchLivePhemex(symbol) {
  try {
    const url = `https://api.phemex.com/md/v2/ticker/24hr?symbol=${symbol}`;
    const r = await proxiedFetch(url);
    if (!r.ok) { console.warn('Phemex API status:', r.status); return null; }
    const body = await r.json();
    if (body.error !== undefined && body.error !== null) {
      console.warn('Phemex API error:', body.error); return null;
    }
    const d = body.result || {};
    const lp = parseFloat(d.closeRp);
    if (!lp || lp <= 0) { console.warn('Phemex bad closeRp:', d.closeRp); return null; }
    const fiHours = phemexFiCache[symbol] || 4;
    const fr = parseFloat(d.fundingRateRr || '0');
    const fr8h = fiHours > 0 ? fr * (8 / fiHours) : 0;
    return {
      last_price: lp,
      mark_price: parseFloat(d.markPriceRp || '0'),
      index_price: parseFloat(d.indexPriceRp || '0'),
      funding_rate: fr,
      funding_interval_hours: fiHours,
      funding_rate_8h: fr8h,
    };
  } catch (e) { console.warn('Phemex fetch error:', e); return null; }
}

function renderLatest(gate, phemex) {
  const gLast = gate.last_price, pLast = phemex.last_price;
  const gap = pLast ? ((gLast - pLast) / pLast * 100) : 0;
  const gFR8h = gate.funding_rate_8h * 100;
  const pFR8h = phemex.funding_rate_8h * 100;
  const frGap = gFR8h - pFR8h;

  const cls = v => v >= 0 ? 'pos' : 'neg';
  const sign = v => v >= 0 ? '+' : '';

  document.getElementById('latest').innerHTML = `
    <div class="card">
      <h3>Last Price</h3>
      <div>Gate: <span class="val">${gLast.toFixed(4)}</span></div>
      <div>Phemex: <span class="val">${pLast.toFixed(4)}</span></div>
    </div>
    <div class="card">
      <h3>Price Gap (Gate - Phemex)</h3>
      <div class="val ${cls(gap)}">${sign(gap)}${gap.toFixed(4)}%</div>
    </div>
    <div class="card">
      <h3>FR (8h Normalized)</h3>
      <div>Gate: <span class="${cls(gFR8h)}">${sign(gFR8h)}${gFR8h.toFixed(4)}%</span> (${gate.funding_interval_hours.toFixed(0)}h)</div>
      <div>Phemex: <span class="${cls(pFR8h)}">${sign(pFR8h)}${pFR8h.toFixed(4)}%</span> (${phemex.funding_interval_hours.toFixed(0)}h)</div>
      <div>Gap: <span class="val ${cls(frGap)}">${sign(frGap)}${frGap.toFixed(4)}%</span></div>
    </div>
  `;
}

function latestFromCSV(rows) {
  const gate = rows.filter(r => r.exchange === 'gate');
  const phemex = rows.filter(r => r.exchange === 'phemex');
  const g = gate[gate.length - 1];
  const p = phemex[phemex.length - 1];
  if (!g || !p) return null;
  return {
    gate: {
      last_price: parseFloat(g.last_price),
      mark_price: parseFloat(g.mark_price),
      index_price: parseFloat(g.index_price),
      funding_rate_8h: parseFloat(g.funding_rate_8h),
      funding_interval_hours: parseFloat(g.funding_interval_h || '0'),
    },
    phemex: {
      last_price: parseFloat(p.last_price),
      mark_price: parseFloat(p.mark_price),
      index_price: parseFloat(p.index_price),
      funding_rate_8h: parseFloat(p.funding_rate_8h),
      funding_interval_hours: parseFloat(p.funding_interval_h || '0'),
    }
  };
}

async function refreshLive() {
  const symbols = PAIR_SYMBOLS[currentPair];
  if (!symbols) return;
  const badge = document.getElementById('liveBadge');
  const now = new Date().toLocaleTimeString();

  // Try live API first
  const [gate, phemex] = await Promise.all([
    fetchLiveGate(symbols.gate),
    fetchLivePhemex(symbols.phemex),
  ]);

  if (gate && phemex) {
    renderLatest(gate, phemex);
    badge.textContent = 'LIVE';
    badge.className = 'live-badge';
    document.getElementById('status').textContent =
      `${currentPair} | LIVE ${now} | Next: ${LIVE_REFRESH_SEC}s`;
    return;
  }

  // Fallback: show latest from CSV
  console.warn('Live API failed, falling back to CSV. gate:', !!gate, 'phemex:', !!phemex);
  let rows = await fetchCSV(todayStr(), currentPair);
  if (rows.length === 0) rows = await fetchCSV(yesterdayStr(), currentPair);
  const csv = latestFromCSV(rows);
  if (csv) {
    renderLatest(csv.gate, csv.phemex);
    badge.textContent = 'CSV';
    badge.className = 'live-badge error';
    document.getElementById('status').textContent =
      `${currentPair} | CSV fallback ${now} | API unavailable`;
  } else {
    badge.textContent = 'OFFLINE';
    badge.className = 'live-badge error';
    document.getElementById('status').textContent =
      `${currentPair} | No data available | ${now}`;
  }
}

// --- Chart updates (from CSV) ---

function updateCharts(rows) {
  const gate = rows.filter(r => r.exchange === 'gate');
  const phemex = rows.filter(r => r.exchange === 'phemex');

  charts.chartLast.data.datasets = [
    { label: 'Gate', data: gate.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.last_price) })),
      borderColor: CHART_COLORS.gate, borderWidth: 1.5, pointRadius: 0, tension: 0.2 },
    { label: 'Phemex', data: phemex.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.last_price) })),
      borderColor: CHART_COLORS.phemex, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartLast.update();

  const gapData = [];
  const gateMap = new Map(gate.map(r => [r.timestamp, r]));
  phemex.forEach(p => {
    const g = gateMap.get(p.timestamp);
    if (g) {
      const gp = parseFloat(g.last_price), pp = parseFloat(p.last_price);
      if (pp) gapData.push({ x: new Date(p.timestamp), y: ((gp - pp) / pp * 100) });
    }
  });
  charts.chartGap.data.datasets = [
    { label: 'Gap %', data: gapData, borderColor: CHART_COLORS.gap, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartGap.update();

  charts.chartFR.data.datasets = [
    { label: 'Gate FR(8h)', data: gate.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.funding_rate_8h) * 100 })),
      borderColor: CHART_COLORS.gate, borderWidth: 1.5, pointRadius: 0, tension: 0.2 },
    { label: 'Phemex FR(8h)', data: phemex.map(r => ({ x: new Date(r.timestamp), y: parseFloat(r.funding_rate_8h) * 100 })),
      borderColor: CHART_COLORS.phemex, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartFR.options.scales.y.ticks.callback = v => v.toFixed(2) + '%';
  charts.chartFR.update();

  const frGapData = [];
  phemex.forEach(p => {
    const g = gateMap.get(p.timestamp);
    if (g) {
      frGapData.push({ x: new Date(p.timestamp), y: (parseFloat(g.funding_rate_8h) - parseFloat(p.funding_rate_8h)) * 100 });
    }
  });
  charts.chartFRGap.data.datasets = [
    { label: 'FR(8h) Gap', data: frGapData, borderColor: CHART_COLORS.gap, borderWidth: 1.5, pointRadius: 0, tension: 0.2 }
  ];
  charts.chartFRGap.options.scales.y.ticks.callback = v => v.toFixed(2) + '%';
  charts.chartFRGap.update();
}

async function refreshCharts() {
  const rows = await fetchCSV(todayStr(), currentPair);
  let allRows = rows;
  if (rows.length === 0) {
    allRows = await fetchCSV(yesterdayStr(), currentPair);
  }
  if (allRows.length === 0) {
    Object.values(charts).forEach(c => { c.data.datasets = []; c.update(); });
    return;
  }
  updateCharts(allRows);
}

// --- Init ---

async function init() {
  initCharts();
  renderTabs();
  await fetchPhemexFundingIntervals();
  refreshLive();
  refreshCharts();
  setInterval(refreshLive, LIVE_REFRESH_SEC * 1000);
  setInterval(refreshCharts, CHART_REFRESH_SEC * 1000);
}

init();
</script>
</body>
</html>
